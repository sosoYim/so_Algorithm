/*
N개의 수로 이루어진 수열이 주어집니다.
이 수열에서 홀수의 개수가 k개인 연속부분수열의 개수를 구하려고 합니다.
만약 N=5인 수열이 아래와 같고
[1, 2, 1, 1, 2]
k=2라면 홀수의 개수가 2개인 연속부분수열은
[1, 2, 1], [2, 1, 1], [2, 1, 1, 2], [1, 1], [1, 1, 2] 로 5가지입니다.

▣ 입력설명
매개변수 nums에 N(1≤N≤100,000)길이의 수열이 주어집니다.
매개변수 k에 k(1≤k≤20,000)이 주어집니다.
수열의 원소값은 1,000을 넘지 않는 자연수입니다.

▣ 출력설명
경우의 수를 반환합니다.

▣ 매개변수 형식 1
[1, 2, 1, 1, 2], 2

▣ 반환값 형식 1
5

▣ 매개변수 형식 2
[2, 2, 2, 1, 2, 2, 1, 2, 2, 2], 2

▣ 반환값 형식 2
16

▣ 매개변수 형식 3
[2, 4, 6], 1

▣ 반환값 형식 3
0
*/

function solution(nums, k) {
  let answer = 0;
  let cnt = 0;
  let sM = new Map();
  // 각각의 위치마다 홀수의 갯수가 몇개인지 체크하고
  // 홀수의 갯수를 가질 수 있는 경우에 +1 해준다.
  // 홀수 갯수 : 기존값+1
  for (const x of nums) {
    if (x % 2) cnt += 1;
    sM.set(cnt, (sM.get(cnt) || 0) + 1);
    console.log(sM);
    if (cnt === k) answer += 1;
    // 현재 카운트 - k(필요한 카운트 갯수) 의 경우의 수가 맵에 등록이 되어있다면
    // 현재 카운트에서 이 경우의 수(불순물)를 빼면
    // k 개의 홀수를 가진 경우의 수를 구할 수 있다.
    if (sM.has(cnt - k)) answer += sM.get(cnt - k);
  }
  return answer;
}

console.log(solution([2, 2, 2, 1, 2, 2, 1, 2, 2, 2], 2));
