/*
미로의 최단거리 통로(BFS)
7*7 격자판 미로를 탈출하는 최단경로의 길이를 출력하는 프로그램을 작성하세요. 경로의 길
이는 출발점에서 도착점까지 가는데 이동한 횟수를 의미한다. 출발점은 격자의 (1, 1) 좌표이
고, 탈출 도착점은 (7, 7)좌표이다. 격자판의 1은 벽이고, 0은 도로이다.
격자판의 움직임은 상하좌우로만 움직인다. 미로가 다음과 같다면
출발 0 0 0 0 0 0
0 1 1 1 1 1 0
0 0 0 1 0 0 0
1 1 0 1 0 1 1
1 1 0 1 0 0 0
1 0 0 0 1 0 0
1 0 1 0 0 0 도착
위와 같은 경로가 최단 경로의 길이는 12이다. 
▣ 입력설명
매개변수 board에 7*7 격자의 정보가 주어집니다.
▣ 출력설명
최단으로 움직인 칸의 수를 반환합니다. 도착할 수 없으면 -1를 출력한다.
▣ 입력예제 1 
[[0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 1, 1, 1, 0], [0, 0, 0, 1, 0, 0, 0], [1, 1, 0, 1, 0, 1, 1], 
[1, 1, 0, 1, 0, 0, 0], [1, 0, 0, 0, 1, 0, 0], [1, 0, 1, 0, 0, 0, 0]]
▣ 출력예제 1
12
*/

function solution(board) {
  const dx = [-1, 0, 1, 0];
  const dy = [0, 1, 0, -1];
  const dist = Array.from({ length: board.length }, () => Array(board.length).fill(0));

  function BFS(x, y) {
    let q = [];
    q.push([x, y]);
    while (q.length) {
      const [curX, curY] = q.shift();
      for (let i = 0; i < 4; i++) {
        const nX = curX + dx[i];
        const nY = curY + dy[i];
        if (nX >= 0 && nY >= 0 && nX < 7 && nY < 7 && board[nX][nY] === 0) {
          board[nX][nY] = 1;
          q.push([nX, nY]);
          dist[nX][nY] = dist[curX][curY] + 1;
        }
      }
    }
  }
  BFS(0, 0);

  return dist[6][6] === 0 ? -1 : dist[6][6];
}

console.log(
  solution([
    [0, 0, 0, 0, 0, 0, 0],
    [0, 1, 1, 1, 1, 1, 0],
    [0, 0, 0, 1, 0, 0, 0],
    [1, 1, 0, 1, 0, 1, 1],
    [1, 1, 0, 1, 0, 0, 0],
    [1, 0, 0, 0, 1, 0, 0],
    [1, 0, 1, 0, 0, 0, 0],
  ])
);
